from mcp.server.fastmcp import FastMCP
import requests
import json
import os
from openai import OpenAI
import tempfile
from dotenv import load_dotenv

# Load environment variables from a .env file if present
load_dotenv()

# Initialize OpenAI client with API key from environment variable
api_key = os.environ.get("OPENAI_API_KEY")
if not api_key:
    print("Warning: OPENAI_API_KEY environment variable not set. Please set it in your .env file.")
    # You can set a default API key here if needed
    # api_key = "your-default-api-key"

client = OpenAI(api_key=api_key)

VECTOR_STORE_NAME = "MEMORIES_PRODUCT"

mcp = FastMCP("Order")

def get_or_create_vector_store(store_id: str):
    # Try to find existing vector store, else create
    stores = client.vector_stores.list()
    for store in stores:
        if store.name == f"{VECTOR_STORE_NAME}_{store_id}":
            return store
    return client.vector_stores.create(name=f"{VECTOR_STORE_NAME}_{store_id}")


@mcp.tool("learn-product-data")
def learn_product_data(api_token: str, store_id: str, is_delete: bool = False, page: int = 1) -> str:
    """
    Fetches product data from a specified API URL using POST method
    and saves it to product_link_id.json file
    
    Args:
        api_token: The API token for authentication
        store_id: The ID of the store to fetch products from
        is_delete: Whether to delete existing files in the vector store
        page: The page number to fetch products from
    """
    try:
        vector_store = get_or_create_vector_store(store_id)
        # Delete all existing files in the vector store
        try:
            files = client.vector_stores.files.list(vector_store_id=vector_store.id)
            if is_delete:
                for file in files:
                    client.vector_stores.files.delete(vector_store_id=vector_store.id, file_id=file.id)
        except Exception as e:
            return f"Error deleting existing files from vector store: {str(e)}"
        

        # Send GET request to the API
        # Initialize variables for pagination
        max_page = page + 5
        limit = 100
        total_products = 0
        file_ids = []  # List to store all file IDs
        
        while True:
            # Add pagination parameters to the API URL
            if not api_token or not store_id:
                return "Error: API token or store ID is missing"
            api_url = f"https://dev-api.oda.vn/web/v1/guest/automation/product-study/{api_token}/{store_id}?page={page}&limit={limit}"
            response = requests.post(api_url)
            response.raise_for_status()  # Raise exception for HTTP errors
            
            # Parse the JSON response
            response_json = response.json()
            
            # Check if response_json has a 'data' key
            if isinstance(response_json, dict) and 'data' in response_json:
                data = response_json['data']
            else:
                data = response_json
            
            # Check if there's no more product data
            if not data:
                break
                
        
            # If data is a list, check if it's empty
            if isinstance(data, list):
                if not data:
                    break
                
                # Process this page of data
                page_data = {}
                page_product_count = 0
                for product in data:
                    if 'id' in product:
                        page_data[product['id']] = product
                        page_product_count += 1
                    elif 'product_id' in product:
                        page_data[product['product_id']] = product
                        page_product_count += 1
                
                total_products += page_product_count
                
                # Write this page of data to vector store
                with tempfile.NamedTemporaryFile(mode="w+", delete=False, suffix=".txt") as f:
                    # Convert dictionary to JSON string
                    json_data = json.dumps(page_data)
                    f.write(json_data)
                    f.flush()
                    try:
                        # Upload the file directly to the vector store
                        # The file_id will be generated by the API
                        file_response = client.vector_stores.files.upload(
                            vector_store_id=vector_store.id,
                            file=open(f.name, "rb")
                        )
                        
                        # Store the file ID with page information
                        current_file_id = file_response.id
                        file_ids.append(f"page_{page}:{current_file_id}")
                    except Exception as e:
                        return f"Error uploading page {page} to vector store: {str(e)}"
                
                # If fewer items than limit, we've reached the end
                if len(data) < limit:
                    break
                page += 1
                if page > max_page:
                    break
        
        # Return success message as string
        return f"Successfully saved {total_products} products to vector store {vector_store.id} with file ids: {', '.join(file_ids)}"
    except requests.exceptions.RequestException as e:
        return f"Error fetching data from API: {str(e)}"
    except json.JSONDecodeError:
        return "Error: The API response is not valid JSON"
    except Exception as e:
        return f"Unexpected error: {str(e)}"

@mcp.tool("delete-product-data")
def delete_product_data(store_id: str):
    """Delete all existing files in the vector store"""
    try:
        vector_store = get_or_create_vector_store(store_id)
        files = client.vector_stores.files.list(vector_store_id=vector_store.id)
        for file in files:
            client.vector_stores.files.delete(vector_store_id=vector_store.id, file_id=file.id)
        return f"Successfully deleted all existing files from vector store {vector_store.id}"
    except Exception as e:
        return f"Error deleting existing files from vector store: {str(e)}"
    
@mcp.tool()
def seach_product_id(product_name: str, supplier_company_id: str, buy_company_id: str):
    """Search memories in the vector store and return relevant chunks."""
    vector_store = get_or_create_vector_store(supplier_company_id + '_' + buy_company_id)
    
    # The OpenAI API search method doesn't support filtering by file_ids directly
    # We'll use the standard search method which searches across all files in the vector store
    
    # Check if there are any files in the vector store
    files = client.vector_stores.files.list(vector_store_id=vector_store.id)
    if not files.data:
        return []
    
    # Enhance the query to improve fuzzy matching
    # Add some context to help the vector search understand we're looking for products
    enhanced_query = f"Find product name similar to: {product_name}"
    
    # Search across the vector store with improved parameters for better matching
    results = client.vector_stores.search(
        vector_store_id=vector_store.id,
        query=enhanced_query,
        max_num_results=50  # Increase results to find more potential matches
    )

    content_texts = [
        content.text
        for item in results.data
        for content in item.content
        if content.type == "text"
    ]

    return content_texts

@mcp.tool()
def process_order_product(product_ids: list[str], product_names: list[str], quantities: list[int], notes: list[str]):
    """Format product information into a JSON object with product_name, product_id, quantity, and note.
    
    Args:
        product_ids: The ID of the product
        product_names: The name of the product
        quantities: The quantity of the product
        notes: Any additional notes for the product
        
    Returns:
        JSON formatted order object with product information
    """
    import json
    
    # Create product info object
    order_info = []
    for product_id, product_name, quantity, note in zip(product_ids, product_names, quantities, notes):
        order_info.append({
            "product_name": product_name,
            "product_id": product_id,
            "quantity": quantity,
            "note": note if note is not None else ""
        })
    
    # Return as JSON string
    return json.dumps(order_info)

@mcp.tool()
def create_oda_order(api_token: str, supplier_company_id: str, buy_company_id: str, order_info: list):
    """
    Creates a draft order in ODA.

    Args:
        api_token: The API token for authentication.
        supplier_company_id: The ID of the supplier company.
        buy_company_id: The ID of the buy company.
        order_info: A list of dictionaries representing the order information.

    Returns:
        The response from the ODA API.
    """
    import json

    api_url = f"https://dev-api.oda.vn/web/v1/guest/automation/make-draft-order/{api_token}/{supplier_company_id}/{buy_company_id}"
    
    try:
        # No need to parse JSON, order_info is already a list
        payload = {"order": order_info}
        response = requests.post(api_url, json=payload)
        response.raise_for_status()  # Raise an exception for bad status codes
        return response.json()
    except requests.exceptions.RequestException as e:
        return {"error": f"API request failed: {e}"}
    except Exception as e:
        return {"error": f"Unexpected error: {str(e)}"}
        
if __name__ == "__main__":
    mcp.run()
